<response>
  <status>FIXED</status>
  <thought>
    1.  **Analyzed Errors**: The compiler complained about missing `ProductCreateRequest` and `MethodSource`.
    2.  **Identified Missing Imports**:
        -   `com.example.demo.dto.ProductCreateRequest`
        -   `com.example.demo.dto.ProductResponse`
        -   `org.junit.jupiter.params.provider.MethodSource`
        -   `com.example.demo.exception.ProductNotFoundException` (replaced `ResourceNotFoundException`)
        -   `java.math.BigDecimal`
        -   `java.util.List`
        -   `org.springframework.http.MediaType`
        -   `org.springframework.test.web.servlet.ResultActions`
        -   Static imports for `MockMvcResultMatchers` (status, jsonPath, content) and `MockMvcRestDocumentation` (document), and `PayloadDocumentation` / `RequestDocumentation`.
    3.  **Refactoring**:
        -   Replaced `ResourceNotFoundException` with `ProductNotFoundException` which is the actual exception in the project.
        -   Added `RestDocumentationRequestBuilders` static import for `get` to match the usage `get("/products/{id}", ...)` with RestDocs.
    4.  **Verification**: The fix addresses specific compilation errors and aligns with the project structure found in `com.example.demo`.
  </thought>
  <code><![CDATA[
package com.example.demo.presentation;

import com.example.demo.dto.ProductCreateRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.exception.ProductNotFoundException;
import com.example.demo.service.ProductService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.restdocs.RestDocumentationExtension;
import org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import java.math.BigDecimal;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders.get;
import static org.springframework.restdocs.payload.PayloadDocumentation.fieldWithPath;
import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;
import static org.springframework.restdocs.request.RequestDocumentation.parameterWithName;
import static org.springframework.restdocs.request.RequestDocumentation.pathParameters;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(ProductController.class)
@AutoConfigureRestDocs
@ExtendWith(RestDocumentationExtension.class)
@DisplayName("ProductController Layer Test")
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private ProductService productService;

    @BeforeEach
    void setUp() {
        // Setup logic for MockMvc or global mock behaviors
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("Describe_createProduct")
    class Describe_createProduct {

        @Test
        @DisplayName("with valid attributes, it creates a product and returns 201 Created")
        void it_creates_product() throws Exception {
            // given
            ProductCreateRequest request = ProductCreateRequest.builder()
                    .name("Test Product")
                    .price(new BigDecimal("100.00"))
                    .stockQuantity(50L)
                    .build();
            ProductResponse response = ProductResponse.builder()
                    .id(1L)
                    .name("Test Product")
                    .price(new BigDecimal("100.00"))
                    .stockQuantity(50L)
                    .build();
            given(productService.createProduct(any(ProductCreateRequest.class))).willReturn(response);

            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.post("/products")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(request)));

            // then
            result.andExpect(status().isCreated())
                    .andExpect(jsonPath("$.id").value(1L))
                    .andExpect(jsonPath("$.name").value("Test Product"))
                    .andExpect(jsonPath("$.price").value(100.00))
                    .andDo(document("create-product"));
        }

        @ParameterizedTest(name = "{0}")
        @MethodSource("provideInvalidRequests")
        @DisplayName("with invalid attributes, it returns 400 Bad Request")
        void it_returns_bad_request(String description, ProductCreateRequest invalidRequest) throws Exception {
            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.post("/products")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(invalidRequest)));

            // then
            result.andExpect(status().isBadRequest())
                    .andDo(document("create-product-error-" + description.replace(" ", "-")));
        }

        private static java.util.stream.Stream<org.junit.jupiter.params.provider.Arguments> provideInvalidRequests() {
            return java.util.stream.Stream.of(
                    org.junit.jupiter.params.provider.Arguments.of("null name", ProductCreateRequest.builder().name(null).price(new BigDecimal("100.00")).stockQuantity(10L).build()),
                    org.junit.jupiter.params.provider.Arguments.of("empty name", ProductCreateRequest.builder().name("").price(new BigDecimal("100.00")).stockQuantity(10L).build()),
                    org.junit.jupiter.params.provider.Arguments.of("negative price", ProductCreateRequest.builder().name("Valid Name").price(new BigDecimal("-1.00")).stockQuantity(10L).build()),
                    org.junit.jupiter.params.provider.Arguments.of("null price", ProductCreateRequest.builder().name("Valid Name").price(null).stockQuantity(10L).build()),
                    org.junit.jupiter.params.provider.Arguments.of("negative stock", ProductCreateRequest.builder().name("Valid Name").price(new BigDecimal("100.00")).stockQuantity(-5L).build())
            );
        }
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("Describe_getProduct")
    class Describe_getProduct {

        @Test
        @DisplayName("유효한 ID로 조회 시 제품 정보와 200 OK를 반환한다")
        void it_returns_product_with_200_ok() throws Exception {
            // given
            Long productId = 1L;
            ProductResponse response = ProductResponse.builder()
                    .id(productId)
                    .name("Test Product")
                    .price(BigDecimal.valueOf(100.00))
                    .stockQuantity(10L)
                    .build();
            given(productService.getProduct(productId)).willReturn(response);

            // when
            ResultActions result = mockMvc.perform(get("/products/{id}", productId)
                    .accept(MediaType.APPLICATION_JSON));

            // then
            result.andExpect(status().isOk())
                    .andExpect(jsonPath("$.id").value(productId))
                    .andExpect(jsonPath("$.name").value("Test Product"))
                    .andExpect(jsonPath("$.price").value(100.00))
                    .andExpect(jsonPath("$.stockQuantity").value(10))
                    .andDo(document("get-product"));
        }

        @Test
        @DisplayName("존재하지 않는 ID로 조회 시 404 Not Found를 반환한다")
        void it_returns_404_when_product_not_found() throws Exception {
            // given
            Long nonExistentId = 999L;
            given(productService.getProduct(nonExistentId)).willThrow(new ProductNotFoundException("Product not found"));

            // when
            ResultActions result = mockMvc.perform(get("/products/{id}", nonExistentId)
                    .accept(MediaType.APPLICATION_JSON));

            // then
            result.andExpect(status().isNotFound())
                    .andDo(document("get-product-not-found"));
        }
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("Describe_getAllProducts")
    class Describe_getAllProducts {

        @Test
        @DisplayName("저장된 모든 제품 목록을 200 OK와 함께 반환한다")
        void it_returns_all_products() throws Exception {
            // given
            ProductResponse productResponse = ProductResponse.builder()
                    .id(1L)
                    .name("Test Product")
                    .price(BigDecimal.valueOf(12000))
                    .stockQuantity(50L)
                    .build();
            given(productService.getAllProducts()).willReturn(List.of(productResponse));

            // when
            ResultActions result = mockMvc.perform(get("/products").accept(MediaType.APPLICATION_JSON));

            // then
            result.andExpect(status().isOk())
                    .andExpect(jsonPath("$[0].id").value(1L))
                    .andExpect(jsonPath("$[0].name").value("Test Product"))
                    .andExpect(jsonPath("$[0].price").value(12000))
                    .andExpect(jsonPath("$[0].stockQuantity").value(50L))
                    .andDo(document("get-all-products",
                            responseFields(
                                    fieldWithPath("[].id").description("제품 ID"),
                                    fieldWithPath("[].name").description("제품명"),
                                    fieldWithPath("[].price").description("제품 가격"),
                                    fieldWithPath("[].stockQuantity").description("재고 수량")
                            )));
        }
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("Describe_getDiscountedPriceInUsd")
    class Describe_getDiscountedPriceInUsd {

        @Test
        @DisplayName("with a valid product ID, it returns the discounted price in USD")
        void it_returns_discounted_price() throws Exception {
            // given
            Long productId = 100L;
            BigDecimal expectedPrice = new BigDecimal("49.99");
            given(productService.getDiscountedPriceInUsd(productId)).willReturn(expectedPrice);

            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.get("/products/{id}/discounted-price", productId)
                    .accept(MediaType.APPLICATION_JSON));

            // then
            result.andExpect(status().isOk())
                    .andExpect(content().string(expectedPrice.toString()))
                    .andDo(document("get-discounted-price-usd",
                            pathParameters(
                                    parameterWithName("id").description("The unique ID of the product")
                            )));
        }

        @Test
        @DisplayName("with an invalid product ID type, it returns 400 Bad Request")
        void it_returns_bad_request_for_invalid_type() throws Exception {
            // given
            String invalidId = "invalid-type";

            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.get("/products/{id}/discounted-price", invalidId)
                    .accept(MediaType.APPLICATION_JSON));

            // then
            result.andExpect(status().isBadRequest())
                    .andDo(document("get-discounted-price-usd-invalid-type"));
        }
    }

}
]]></code>
</response>