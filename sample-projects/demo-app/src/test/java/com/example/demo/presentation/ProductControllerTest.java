/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-3-pro-preview
 */
package com.example.demo.presentation;

import com.example.demo.dto.ProductCreateRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.exception.ProductNotFoundException;
import com.example.demo.service.ProductService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.restdocs.RestDocumentationExtension;
import org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;
import java.math.BigDecimal;
import java.util.List;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders.get;
import static org.springframework.restdocs.payload.PayloadDocumentation.fieldWithPath;
import static org.springframework.restdocs.payload.PayloadDocumentation.responseFields;
import static org.springframework.restdocs.request.RequestDocumentation.parameterWithName;
import static org.springframework.restdocs.request.RequestDocumentation.pathParameters;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(ProductController.class)
@AutoConfigureRestDocs
@ExtendWith(RestDocumentationExtension.class)
@DisplayName("ProductController Layer Test")
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @MockBean
    private ProductService productService;

    @BeforeEach
    void setUp() {
        // Setup logic for MockMvc or global mock behaviors
    }

    @Nested
    @DisplayName("Describe_createProduct")
    class Describe_createProduct {

        @Test
        @DisplayName("with valid attributes, it creates a product and returns 201 Created")
        void it_creates_product() throws Exception {
            // given
            ProductCreateRequest request = ProductCreateRequest.builder().name("Test Product").price(new BigDecimal("100.00")).stockQuantity(50L).build();
            ProductResponse response = ProductResponse.builder().id(1L).name("Test Product").price(new BigDecimal("100.00")).stockQuantity(50L).build();
            given(productService.createProduct(any(ProductCreateRequest.class))).willReturn(response);
            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.post("/api/products").contentType(MediaType.APPLICATION_JSON).content(objectMapper.writeValueAsString(request)));
            // then
            result.andExpect(status().isCreated()).andExpect(jsonPath("$.id").value(1L)).andExpect(jsonPath("$.name").value("Test Product")).andExpect(jsonPath("$.price").value(100.00)).andDo(document("create-product"));
        }

        @ParameterizedTest(name = "{0}")
        @MethodSource("provideInvalidRequests")
        @DisplayName("with invalid attributes, it returns 400 Bad Request")
        void it_returns_bad_request(String description, ProductCreateRequest invalidRequest) throws Exception {
            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.post("/api/products").contentType(MediaType.APPLICATION_JSON).content(objectMapper.writeValueAsString(invalidRequest)));
            // then
            result.andExpect(status().isBadRequest()).andDo(document("create-product-error-" + description.replace(" ", "-")));
        }

        private static java.util.stream.Stream<org.junit.jupiter.params.provider.Arguments> provideInvalidRequests() {
            return java.util.stream.Stream.of(org.junit.jupiter.params.provider.Arguments.of("null name", ProductCreateRequest.builder().name(null).price(new BigDecimal("100.00")).stockQuantity(10L).build()), org.junit.jupiter.params.provider.Arguments.of("empty name", ProductCreateRequest.builder().name("").price(new BigDecimal("100.00")).stockQuantity(10L).build()), org.junit.jupiter.params.provider.Arguments.of("negative price", ProductCreateRequest.builder().name("Valid Name").price(new BigDecimal("-1.00")).stockQuantity(10L).build()), org.junit.jupiter.params.provider.Arguments.of("null price", ProductCreateRequest.builder().name("Valid Name").price(null).stockQuantity(10L).build()), org.junit.jupiter.params.provider.Arguments.of("negative stock", ProductCreateRequest.builder().name("Valid Name").price(new BigDecimal("100.00")).stockQuantity(-5L).build()));
        }
    }

    @Nested
    @DisplayName("Describe_getProduct")
    class Describe_getProduct {

        @Test
        @DisplayName("유효한 ID로 조회 시 제품 정보와 200 OK를 반환한다")
        void it_returns_product_with_200_ok() throws Exception {
            // given
            Long productId = 1L;
            ProductResponse response = ProductResponse.builder().id(productId).name("Test Product").price(BigDecimal.valueOf(100.00)).stockQuantity(10L).build();
            given(productService.getProduct(productId)).willReturn(response);
            // when
            ResultActions result = mockMvc.perform(get("/api/products/{id}", productId).accept(MediaType.APPLICATION_JSON));
            // then
            result.andExpect(status().isOk()).andExpect(jsonPath("$.id").value(productId)).andExpect(jsonPath("$.name").value("Test Product")).andExpect(jsonPath("$.price").value(100.00)).andExpect(jsonPath("$.stockQuantity").value(10)).andDo(document("get-product"));
        }

        @Test
        @DisplayName("존재하지 않는 ID로 조회 시 404 Not Found를 반환한다")
        void it_returns_404_when_product_not_found() throws Exception {
            // given
            Long nonExistentId = 999L;
            given(productService.getProduct(nonExistentId)).willThrow(new ProductNotFoundException("Product not found"));
            // when
            ResultActions result = mockMvc.perform(get("/api/products/{id}", nonExistentId).accept(MediaType.APPLICATION_JSON));
            // then
            result.andExpect(status().isNotFound()).andDo(document("get-product-not-found"));
        }
    }

    @Nested
    @DisplayName("Describe_getAllProducts")
    class Describe_getAllProducts {

        @Test
        @DisplayName("저장된 모든 제품 목록을 200 OK와 함께 반환한다")
        void it_returns_all_products() throws Exception {
            // given
            ProductResponse productResponse = ProductResponse.builder().id(1L).name("Test Product").price(BigDecimal.valueOf(12000)).stockQuantity(50L).build();
            given(productService.getAllProducts()).willReturn(List.of(productResponse));
            // when
            ResultActions result = mockMvc.perform(get("/api/products").accept(MediaType.APPLICATION_JSON));
            // then
            result.andExpect(status().isOk()).andExpect(jsonPath("$[0].id").value(1L)).andExpect(jsonPath("$[0].name").value("Test Product")).andExpect(jsonPath("$[0].price").value(12000)).andExpect(jsonPath("$[0].stockQuantity").value(50L)).andDo(document("get-all-products", responseFields(fieldWithPath("[].id").description("제품 ID"), fieldWithPath("[].name").description("제품명"), fieldWithPath("[].price").description("제품 가격"), fieldWithPath("[].stockQuantity").description("재고 수량"))));
        }
    }

    @Nested
    @DisplayName("Describe_getDiscountedPriceInUsd")
    class Describe_getDiscountedPriceInUsd {

        @Test
        @DisplayName("with a valid product ID, it returns the discounted price in USD")
        void it_returns_discounted_price() throws Exception {
            // given
            Long productId = 100L;
            BigDecimal expectedPrice = new BigDecimal("49.99");
            given(productService.getDiscountedPriceInUsd(productId)).willReturn(expectedPrice);
            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.get("/api/products/{id}/price/usd", productId).accept(MediaType.APPLICATION_JSON));
            // then
            result.andExpect(status().isOk()).andExpect(content().string(expectedPrice.toString())).andDo(document("get-discounted-price-usd", pathParameters(parameterWithName("id").description("The unique ID of the product"))));
        }

        @Test
        @DisplayName("with an invalid product ID type, it returns 500 Internal Server Error (caught by GlobalExceptionHandler)")
        void it_returns_bad_request_for_invalid_type() throws Exception {
            // given
            String invalidId = "invalid-type";
            // when
            ResultActions result = mockMvc.perform(RestDocumentationRequestBuilders.get("/api/products/{id}/price/usd", invalidId).accept(MediaType.APPLICATION_JSON));
            // then
            // Ideally should be Bad Request, but GlobalExceptionHandler catches Exception -> 500
            result.andExpect(status().isInternalServerError()).andDo(document("get-discounted-price-usd-invalid-type"));
        }
    }
}