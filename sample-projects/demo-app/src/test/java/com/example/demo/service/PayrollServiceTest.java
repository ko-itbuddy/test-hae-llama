/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-2.0-flash
 */
package com.example.demo.service;

import com.example.demo.client.BankClient;
import com.example.demo.repository.PaymentRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.verify;
import static org.mockito.ArgumentMatchers.eq;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullSource;
import static org.mockito.BDDMockito.given;
import java.math.BigDecimal;
import java.math.RoundingMode;
import static org.mockito.Mockito.when;
import com.example.demo.client.BankClient;
import static org.mockito.ArgumentMatchers.eq;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.mockito.BDDMockito;
import org.mockito.Mockito;

@ExtendWith(MockitoExtension.class)
class PayrollServiceTest {

    @Mock
    private BankClient bankClient;

    @Mock
    private PaymentRepository paymentRepository;

    @InjectMocks
    private PayrollService payrollService;

    @BeforeEach
    void setUp() {
    }

    @Nested
    @DisplayName("Describe_processPayroll")
    class Describe_processPayroll {

        @Mock
        private BankClient bankClient;

        @Mock
        private PaymentRepository paymentRepository;

        @InjectMocks
        private PayrollService payrollService;

        @ParameterizedTest
        @CsvSource(value = { "1, 5000000, true", "2, 7000000, true", "3, 10000000, true" })
        @DisplayName("유효한 employeeId와 baseSalary로 급여 처리에 성공하면 true를 반환하고, 은행 송금 및 저장소 저장을 검증한다")
        void should_return_true_when_processPayroll_is_successful(Long employeeId, BigDecimal baseSalary, boolean transferResult) {
            // given
            BigDecimal tax = baseSalary.multiply(new BigDecimal("0.1")).setScale(0, RoundingMode.HALF_UP);
            BigDecimal netSalary = baseSalary.subtract(tax);
            when(bankClient.transfer(employeeId, netSalary)).thenReturn(transferResult);
            // when
            boolean result = payrollService.processPayroll(employeeId, baseSalary);
            // then
            assertThat(result).isTrue();
            verify(bankClient).transfer(employeeId, netSalary);
            verify(paymentRepository).save(employeeId, netSalary);
        }

        @ParameterizedTest
        @CsvSource(value = { "1, 5000000, false", "2, 7000000, false", "3, 10000000, false" })
        @DisplayName("은행 송금이 실패하면 false를 반환하고, 저장소 저장을 수행하지 않음을 검증한다")
        void should_return_false_when_bankTransfer_fails(Long employeeId, BigDecimal baseSalary, boolean transferResult) {
            // given
            BigDecimal tax = baseSalary.multiply(new BigDecimal("0.1")).setScale(0, RoundingMode.HALF_UP);
            BigDecimal netSalary = baseSalary.subtract(tax);
            when(bankClient.transfer(employeeId, netSalary)).thenReturn(transferResult);
            // when
            boolean result = payrollService.processPayroll(employeeId, baseSalary);
            // then
            assertThat(result).isFalse();
            verify(bankClient).transfer(employeeId, netSalary);
            verify(paymentRepository, Mockito.never()).save(employeeId, netSalary);
        }

        @ParameterizedTest
        @CsvSource(value = { "null, 5000000", "1, null", "1, 0" }, nullValues = "null")
        @DisplayName("employeeId가 null이거나 baseSalary가 null 또는 0이면 IllegalArgumentException을 던진다")
        void should_throw_IllegalArgumentException_when_input_is_invalid(Long employeeId, BigDecimal baseSalary) {
            // when, then
            assertThatThrownBy(() -> payrollService.processPayroll(employeeId, baseSalary)).isInstanceOf(IllegalArgumentException.class).hasMessage("Invalid input data");
        }
    }
}