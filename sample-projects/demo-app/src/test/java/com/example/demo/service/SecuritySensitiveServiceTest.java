/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-3-pro-preview
 */
package com.example.demo.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.verify;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.Mock;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullSource;
import static org.mockito.BDDMockito.given;

@ExtendWith(MockitoExtension.class)
@DisplayName("SecuritySensitiveService 유닛 테스트")
class SecuritySensitiveServiceTest {

    @InjectMocks
    private SecuritySensitiveService securitySensitiveService;

    @BeforeEach
    void setUp() {
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("calculateDynamicPricing 메서드는")
    class Describe_calculateDynamicPricing {

        private final double SECRET_COEFFICIENT = 0.987654321;

        @ParameterizedTest(name = "수요 레벨이 {0}일 때 멀티플라이어 {1}를 적용한다")
        @CsvSource({ "0, 1.0", "5, 1.0", "6, 1.2", "10, 1.2" })
        @DisplayName("수요 레벨에 따라 고정된 멀티플라이어를 적용하여 가격을 계산한다")
        void it_calculates_price_with_fixed_multiplier(int demandLevel, double multiplier) {
            // given
            double basePrice = 1000.0;
            // when
            double result = securitySensitiveService.calculateDynamicPricing(basePrice, demandLevel);
            // then
            double expected = basePrice * multiplier * SECRET_COEFFICIENT;
            assertThat(result).isEqualTo(expected);
        }

        @Test
        @DisplayName("수요가 10을 초과하면 1.5배에서 2.0배 사이의 무작위 가격을 반환한다")
        void it_calculates_price_with_random_multiplier_for_high_demand() {
            // given
            double basePrice = 1000.0;
            int demandLevel = 11;
            // when
            double result = securitySensitiveService.calculateDynamicPricing(basePrice, demandLevel);
            // then
            // Logic: 1.5 + (Math.random() * 0.5) -> Range [1.5, 2.0)
            double minMultiplier = 1.5;
            double maxMultiplier = 2.0;
            double minExpected = basePrice * minMultiplier * SECRET_COEFFICIENT;
            double maxExpected = basePrice * maxMultiplier * SECRET_COEFFICIENT;
            assertThat(result).isGreaterThanOrEqualTo(minExpected).isLessThan(maxExpected);
        }
    }

    /**
     * Generated by Test-Hae-Llama
     * Tool: Gemini CLI
     * Model: gemini-3-pro-preview
     */
    @Nested
    @DisplayName("callExternalProvider 메서드는")
    class Describe_callExternalProvider {

        @ParameterizedTest(name = "입력값 \"{0}\"이 주어지면 포맷된 응답을 반환한다")
        @ValueSource(strings = { "Test Data", "12345", "!@#$%", "" })
        @DisplayName("유효한 데이터가 주어지면 성공 응답 문자열을 반환한다")
        void it_returns_success_response_with_input_data(String inputData) {
            // given
            // Valid inputs provided by ValueSource
            // when
            String result = securitySensitiveService.callExternalProvider(inputData);
            // then
            assertThat(result).isEqualTo("Success response for " + inputData);
        }

        @Test
        @DisplayName("null이 입력되면 'null' 문자열을 포함한 응답을 반환한다")
        void it_handles_null_input_safely() {
            // given
            String inputData = null;
            // when
            String result = securitySensitiveService.callExternalProvider(inputData);
            // then
            assertThat(result).isEqualTo("Success response for null");
        }
    }
}