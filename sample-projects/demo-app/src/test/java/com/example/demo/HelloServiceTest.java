/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-3-pro-preview
 */
package com.example.demo;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.Mockito.verify;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.Mock;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullSource;
import static org.mockito.BDDMockito.given;

@ExtendWith(MockitoExtension.class)
@DisplayName("HelloService 유닛 테스트")
class HelloServiceTest {

    @InjectMocks
    private HelloService helloService;

    @BeforeEach
    void setUp() {
    }


/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-3-pro-preview
 */
@Nested
@DisplayName("greet 메서드는")
class Describe_greet {

    @Test
    @DisplayName("유효한 이름이 주어지면 환영 인사를 반환한다")
    void it_returns_greeting_message_when_name_is_valid() {
        // given
        final String name = "Developer";
        // when
        final String result = helloService.greet(name);
        // then
        assertThat(result).isEqualTo("Hello, Developer!");
    }

    @ParameterizedTest(name = "입력값: \"{0}\"")
    @NullSource
    @ValueSource(strings = { "", " ", "   ", "\t", "\n" })
    @DisplayName("이름이 null이거나 공백이면 예외를 던진다")
    void it_throws_exception_when_name_is_invalid(String invalidName) {
        // given
        // Invalid input provided by parameterized source
        // when & then
        assertThatThrownBy(() -> helloService.greet(invalidName)).isInstanceOf(IllegalArgumentException.class).hasMessage("Name cannot be empty");
    }

    @Test
    @DisplayName("이름이 50자를 초과하면 예외를 던진다")
    void it_throws_exception_when_name_is_too_long() {
        // given
        final String longName = "A".repeat(51);
        // when & then
        assertThatThrownBy(() -> helloService.greet(longName)).isInstanceOf(IllegalArgumentException.class).hasMessage("Name is too long");
    }
}

/**
 * Generated by Test-Hae-Llama
 * Tool: Gemini CLI
 * Model: gemini-3-pro-preview
 */
@Nested
@DisplayName("calculateAge 메서드는")
class Describe_calculateAge {

    @ParameterizedTest(name = "출생년도 {0}, 현재년도 {1}일 때 나이는 {2}이어야 한다")
    @CsvSource({ "2000, 2023, 23", "1990, 2023, 33", "2023, 2023, 0", "1900, 2023, 123" })
    @DisplayName("유효한 출생년도와 현재년도가 주어지면 정확한 나이를 반환한다")
    void it_calculates_age_correctly(int birthYear, int currentYear, int expectedAge) {
        // given (parameterized)
        // when
        int actualAge = helloService.calculateAge(birthYear, currentYear);
        // then
        assertThat(actualAge).isEqualTo(expectedAge);
    }

    @ParameterizedTest(name = "출생년도 {0}이 현재년도 {1}보다 미래일 경우 예외가 발생한다")
    @CsvSource({ "2024, 2023", "3000, 2023" })
    @DisplayName("출생년도가 현재년도보다 미래일 경우 IllegalArgumentException을 던진다")
    void it_throws_exception_when_birthYear_is_in_the_future(int birthYear, int currentYear) {
        // given (parameterized)
        // when & then
        assertThatThrownBy(() -> helloService.calculateAge(birthYear, currentYear)).isInstanceOf(IllegalArgumentException.class).hasMessage("Birth year cannot be in the future");
    }
}

}